# Generated by Selenium IDE
# import pytest
import time
import re
from PyQt5.QtCore import QObject, pyqtSignal

from selenium import webdriver
import selenium
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.common.by import By
from selenium.webdriver.common.action_chains import ActionChains
from selenium.webdriver.support.wait import WebDriverWait
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.common.desired_capabilities import DesiredCapabilities
from selenium.webdriver.support import expected_conditions as EC

from dbm import HistoryMgr
from Config import CONFIG
from BKLOG import *


class ChannelMessageSending(QObject):
    running = pyqtSignal()
    finished = pyqtSignal()
    inserted = pyqtSignal(str)
    dupped = pyqtSignal(str, str)
    in_processing = pyqtSignal(int)
    one_processed = pyqtSignal(dict)
    need_msg = pyqtSignal()

    def __init__(self):
        super().__init__()
        self.loop_flag = True

        self.setup_method()
        self.user_msgs = []
        # self.users.append(user)

    def __del__(self):
        # INFO(f"채널 자동화 instance 삭제")
        self.teardown_method(None)

    def stop(self):
        self.loop_flag = False

    def get_chat_room(self, user):
        mgr = HistoryMgr()

        sql = f"SELECT no, user_name, chat_room, reg_dtm \n"
        sql += f"FROM user \n"
        sql += f"WHERE \n"
        sql += f"user_name = '{user}'\n"
        # sql += f"LIMIT {self.PAGE_SIZE} OFFSET {self.PAGE_SIZE*(self.current_page-1)}"

        DEBUG(f"sql = [{sql}]")
        # INFO(f"sql = [{sql}]")

        self.data = mgr.query(sql)

        DEBUG(f"data = [{self.data}]")
        # INFO(f"data = [{self.data}]")

        if len(self.data) == 1:
            return self.data[0]["chat_room"]
        else:
            return user

    def setup_method(self):
        options = Options()
        options.add_experimental_option("excludeSwitches", ["enable-logging"])
        # options.headless = True

        self.driver = webdriver.Chrome(
            executable_path="./driver/chromedriver.exe", options=options
        )
        # self.driver = webdriver.Chrome()

        self.vars = {}

    def teardown_method(self, method):
        self.driver.quit()

    def wait_for_window(self, timeout=2):
        time.sleep(round(timeout / 1000))
        wh_now = self.driver.window_handles
        wh_then = self.vars["window_handles"]
        if len(wh_now) > len(wh_then):
            return set(wh_now).difference(set(wh_then)).pop()

    # def sendMessage(self):
    def run(self):
        self.running.emit()
        # Test name: 메시지 발송 테스트2
        # Step # | name | target | value
        # 1 | open | / |
        self.driver.get("https://center-pf.kakao.com/")
        # 2 | setWindowSize | 517x770 |
        self.driver.set_window_size(567, 770)

        ## 로그인 분기처리
        # accounts.kakao.com/login
        DEBUG(f"url = [{self.driver.current_url}]")

        dashboard_pattern = re.compile(r"^https://business.kakao.com/dashboard")
        login_pattern = re.compile(r"^https://accounts.kakao.com/login")

        if login_pattern.match(self.driver.current_url):
            # 로그인 처리 필요
            DEBUG(f"로그인 필요!!")
            try:
                # 3 | click | id=id_email_2 |
                # self.driver.find_element(By.XPATH, "//input[@id='id_email_2']").click()
                # 4 | type | id=id_email_2 |
                self.driver.find_element(
                    By.XPATH, "//input[@id='id_email_2']"
                ).send_keys(CONFIG["channel_login"]["user_id"])
                # 5 | click | id=id_password_3 |
                # self.driver.find_element(By.XPATH, "//input[@id='id_password_3']").click()
                # 7 | type | id=id_password_3 |
                self.driver.find_element(
                    By.XPATH, "//input[@id='id_password_3']"
                ).send_keys(CONFIG["channel_login"]["user_pw"])
                # 6 | sendKeys | id=id_password_3 | ${KEY_ENTER}
                self.driver.find_element(
                    By.XPATH, "//input[@id='id_password_3']"
                ).send_keys(Keys.ENTER)
            except selenium.common.exceptions.ElementClickInterceptedException as ecie:
                DEBUG(f"skip login error, have to login manually [{ecie}]")

            while True:
                if dashboard_pattern.match(self.driver.current_url):
                    # 로그인 되었음
                    # time.sleep(1)
                    break

                time.sleep(5)

            # click | css=.link_title |
            # time.sleep(1)
            # self.driver.find_element(By.CSS_SELECTOR, ".link_title").click()
            self.driver.find_element(
                By.XPATH,
                "//a[contains(@href, 'https://center-pf.kakao.com/_RdKNT/dashboard')]",
            ).click()

        elif dashboard_pattern.match(self.driver.current_url):
            # 이미 로그인 되어 있음
            # 3 | click | css=.tit_invite |
            self.driver.find_element(By.CSS_SELECTOR, ".tit_invite").click()
            # 3 | click | css=.tit_invite |
            # self.driver.find_element(By.CSS_SELECTOR, ".tit_invite").click()
            # self.driver.find_element(By.XPATH, "//strong[contains(.,\'리드101송도학원\')]").click()
        else:
            # 3 | click | css=.tit_invite |
            self.driver.find_element(By.CSS_SELECTOR, ".tit_invite").click()

        # if title:
        #   ## 로그인 되어 있음
        #   DEBUG(f"로그인 되어 있음!!")
        # else:
        #   ## 로그인 해야 함
        #   DEBUG(f"로그인 해야함")

        # self.driver.close()

        # 4 | click | xpath=//div[@id='mFeature']/div/div[2]/ul/li[3]/a |
        self.driver.find_element(
            By.XPATH, "//div[@id='mFeature']/div/div[2]/ul/li[3]/a"
        ).click()
        # 5 | click | linkText=채팅 목록 |
        self.driver.find_element(By.LINK_TEXT, "채팅 목록").click()

        while self.loop_flag:
            self.running.emit()
            # msgList에서 발송 대상자를 가져온다.
            self.need_msg.emit()
            time.sleep(1)
            for user_msg in self.user_msgs:
                try:
                    chat_room = self.get_chat_room(user_msg["user"])
                    INFO(f"chat_room = [{chat_room}]")
                    if CONFIG["RUN_MODE"] != "REAL":
                        chat_room = "이범각"
                    # time.sleep(5)
                    # 6 | click | name=keyword |
                    # self.driver.find_element(By.NAME, "keyword").click()
                    # self.driver.find_element(By.NAME, "keyword").click()
                    element = self.driver.find_element(By.NAME, "keyword")
                    actions = ActionChains(self.driver)
                    actions.double_click(element).perform()

                    # 7 | type | name=keyword |
                    # self.driver.find_element(By.NAME, "keyword").send_keys(user_msg["user"])
                    self.driver.find_element(By.NAME, "keyword").clear()
                    self.driver.find_element(By.NAME, "keyword").send_keys(chat_room)
                    # 8 | type | name=keyword |
                    # self.driver.find_element(By.NAME, "keyword").send_keys(user['name'])
                    # 9 | sendKeys | name=keyword | ${KEY_ENTER}
                    self.driver.find_element(By.NAME, "keyword").send_keys(Keys.ENTER)
                    # 10 | click | css=.txt_info:nth-child(1) |
                    self.vars["window_handles"] = self.driver.window_handles

                    time.sleep(1)
                    # 11 | storeWindowHandle | root |
                    # self.driver.find_element(By.CSS_SELECTOR, ".txt_info:nth-child(1)").click()
                    element = WebDriverWait(self.driver, 10).until(
                        EC.presence_of_element_located(
                            (By.CSS_SELECTOR, ".txt_info:nth-child(1)")
                        )
                    )
                    element.click()
                    # 12 | selectWindow | handle=${win1697} |
                    self.vars["win1697"] = self.wait_for_window(2000)
                    # 13 | click | id=chatWrite |
                    self.vars["root"] = self.driver.current_window_handle
                    # 14 | type | id=chatWrite | abc
                    self.driver.switch_to.window(self.vars["win1697"])
                    # 15 | click | css=.btn_g |
                    self.driver.find_element(By.ID, "chatWrite").click()
                    # 16 | close |  |
                    msg_list = user_msg["message"].split(sep="\n")
                    for i, message in enumerate(msg_list):
                        self.driver.find_element(By.ID, "chatWrite").send_keys(message)
                        if i != len(msg_list) - 1:
                            self.driver.find_element(By.ID, "chatWrite").send_keys(
                                Keys.SHIFT + Keys.ENTER
                            )
                    self.driver.find_element(By.ID, "chatWrite").send_keys(Keys.ENTER)
                    time.sleep(1)
                    # 17 | selectWindow | handle=${root} |
                    # self.driver.find_element(By.CSS_SELECTOR, ".btn_g").click()
                    # 18 | click | name=keyword |
                    self.driver.close()
                    # 19 | click | css=.box_tf |
                    self.driver.switch_to.window(self.vars["root"])

                    self.one_processed.emit(user_msg)

                except selenium.common.exceptions.TimeoutException as te:
                    ERROR(f"[{user_msg}] 메시지 전송에 실패하였습니다. [{te}]")
                finally:
                    del self.user_msgs[0]

            # # 20 | type | name=keyword | 이시은
            # self.driver.find_element(By.NAME, "keyword").click()
            # # 21 | sendKeys | name=keyword | ${KEY_ENTER}
            # self.driver.find_element(By.CSS_SELECTOR, ".box_tf").click()
            # # 22 | click | css=.txt_info:nth-child(1) |
            # self.driver.find_element(By.NAME, "keyword").send_keys("이시은")
            # # 23 | selectWindow | handle=${win4320} |
            # self.driver.find_element(By.NAME, "keyword").send_keys(Keys.ENTER)
            # # 24 | click | id=chatWrite |
            # self.vars["window_handles"] = self.driver.window_handles
            # # 25 | type | id=chatWrite | test
            # self.driver.find_element(By.CSS_SELECTOR, ".txt_info:nth-child(1)").click()
            # # 26 | click | css=.btn_g |
            # self.vars["win4320"] = self.wait_for_window(2000)
            # # 27 | close |  |
            # self.driver.switch_to.window(self.vars["win4320"])
            # # 28 | selectWindow | handle=${root} |
            # self.driver.find_element(By.ID, "chatWrite").click()
            # # 29 | close |  |
            # self.driver.find_element(By.ID, "chatWrite").send_keys("test")
            # self.driver.find_element(By.CSS_SELECTOR, ".btn_g").click()
            # self.driver.close()
            # self.driver.switch_to.window(self.vars["root"])

            # 10초간 sleep
            # time.sleep(2)

        # self.driver.close()
        self.teardown_method(None)


if __name__ == "__main__":
    DEBUG(f"CONFIG[user_id]=[{CONFIG['channel_login']['user_id']}]")
    DEBUG(f"CONFIG[user_pw]=[{CONFIG['channel_login']['user_pw']}]")
    # DEBUG(f"CONFIG=[{CONFIG}]")
    user = {
        "name": "이범각",
        "message": "테스트 입니다.",
    }

    w = ChannelMessageSending(user)
    w.sendMessage()

    # pattern = re.compile(
    #   r"^https://business.kakao.com/dashboard"
    # )

    # if pattern.match("https://accounts.kakao.com/login/kakaobusiness?continue=https://business.kakao.com/dashboard/?sid%3Dpfr"):
    #   DEBUG(f"포함되어 있어")
    # else:
    #   DEBUG(f"포함되어 있지 않아")
